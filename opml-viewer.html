<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¸¦è¯­éŸ³æœ—è¯»çš„å°è¯´é˜…è¯»å™¨</title>
    <style>
        .speech-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 1000;
        }
        
        .speech-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: #3498db;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .speech-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
        }
        
        .speech-btn.active {
            background: #e74c3c;
            animation: pulse 1.5s infinite;
        }
        
        .speech-rate {
            display: flex;
            gap: 5px;
        }
        
        .rate-btn {
            padding: 5px 10px;
            border: 1px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .rate-btn.active {
            background: #3498db;
            color: white;
        }
        
        .reading-highlight {
            background: #fff9c4 !important;
            transition: background 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“š å°è¯´ç›®å½•æµè§ˆå™¨</h1>
            <p>è‡ªåŠ¨å¤„ç†ç¼–ç é—®é¢˜ï¼Œæ˜¾ç¤ºæ­£ç¡®ä¸­æ–‡</p>
        </div>
        
        <div class="controls">
            <button class="control-btn" onclick="loadOPML()">é‡æ–°åŠ è½½</button>
            <button class="control-btn" onclick="exportList()">å¯¼å‡ºæ¸…å•</button>
            <div class="search-box">
                <input type="text" class="search-input" placeholder="æœç´¢ç« èŠ‚..." oninput="searchChapters(this.value)">
            </div>
        </div>
        
        <div id="contentArea">
            <div class="loading">æ­£åœ¨åŠ è½½å°è¯´ç›®å½•...</div>
        </div>
        
        <div class="stats" id="stats"></div>
    </div>
    
    <!-- è¯­éŸ³æ§åˆ¶é¢æ¿ -->
    <div class="speech-controls" id="speechControls" style="display: none;">
        <button class="speech-btn" id="speechPlayBtn" onclick="toggleChapterSpeech()">â–¶ï¸</button>
        <button class="speech-btn" onclick="stopChapterSpeech()">â¹ï¸</button>
        
        <div class="speech-rate">
            <button class="rate-btn active" onclick="setSpeechRate(0.8)">0.8x</button>
            <button class="rate-btn" onclick="setSpeechRate(1.0)">1.0x</button>
            <button class="rate-btn" onclick="setSpeechRate(1.2)">1.2x</button>
            <button class="rate-btn" onclick="setSpeechRate(1.5)">1.5x</button>
        </div>
        
        <select id="chapterVoiceSelect" onchange="changeChapterVoice(this.value)">
            <option value="">é€‰æ‹©è¯­éŸ³</option>
        </select>
        
        <div id="speechStatus" style="font-size: 12px; color: #666; min-width: 80px;">
            å°±ç»ª
        </div>
    </div>

    <script>
        class OPMLViewer {
            constructor() {
                this.chapters = [];
                this.filteredChapters = [];
                this.init();
            }
            
            async init() {
                await this.loadOPML();
            }
            
            async loadOPML() {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½OPMLæ–‡ä»¶...</div>';
                
                try {
                    // å°è¯•ä¸åŒç¼–ç æ–¹å¼åŠ è½½
                    const response = await fetch('novels.opml');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // å°è¯•å¤šç§ç¼–ç 
                    const encodings = ['utf-8', 'gbk', 'gb2312', 'big5'];
                    let xmlText = '';
                    
                    // å…ˆä»¥ ArrayBuffer æ–¹å¼è·å–åŸå§‹æ•°æ®
                    const buffer = await response.arrayBuffer();
                    
                    for (const encoding of encodings) {
                        try {
                            const decoder = new TextDecoder(encoding);
                            xmlText = decoder.decode(buffer);
                            
                            // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
                            if (this.containsChinese(xmlText)) {
                                console.log(`ä½¿ç”¨ç¼–ç : ${encoding}`);
                                break;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    if (!this.containsChinese(xmlText)) {
                        // å¦‚æœè¿˜æ˜¯ä¸è¡Œï¼Œå°è¯•é»˜è®¤utf-8
                        xmlText = new TextDecoder('utf-8').decode(buffer);
                    }
                    
                    // è§£æ XML
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    // æ£€æŸ¥è§£æé”™è¯¯
                    const parserError = xmlDoc.querySelector('parsererror');
                    if (parserError) {
                        throw new Error('XMLè§£æé”™è¯¯ï¼š' + parserError.textContent);
                    }
                    
                    // æå–ä¿¡æ¯
                    this.extractData(xmlDoc);
                    
                } catch (error) {
                    console.error('åŠ è½½å¤±è´¥:', error);
                    this.showError(`åŠ è½½å¤±è´¥: ${error.message}`);
                }
            }
            
            containsChinese(text) {
                // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
                return /[\u4e00-\u9fff]/.test(text);
            }
            
            extractData(xmlDoc) {
                this.chapters = [];
                const outlines = xmlDoc.getElementsByTagName('outline');
                
                // æŸ¥æ‰¾å°è¯´ä¿¡æ¯
                let novelInfo = null;
                for (const outline of outlines) {
                    if (outline.getAttribute('type') === 'novel') {
                        novelInfo = {
                            title: outline.getAttribute('text') || 'æœªçŸ¥å°è¯´',
                            author: outline.getAttribute('author') || 'æœªçŸ¥ä½œè€…',
                            status: outline.getAttribute('status') || 'æœªçŸ¥çŠ¶æ€',
                            totalChapters: outline.getAttribute('totalChapters') || '0'
                        };
                        break;
                    }
                }
                
                // æå–ç« èŠ‚
                for (const outline of outlines) {
                    if (outline.getAttribute('type') === 'file') {
                        const chapter = {
                            id: outline.getAttribute('chapterId') || '',
                            title: outline.getAttribute('text') || '',
                            url: outline.getAttribute('url') || '',
                            filename: outline.getAttribute('text') || ''
                        };
                        
                        if (chapter.title && chapter.url) {
                            this.chapters.push(chapter);
                        }
                    }
                }
                
                // æŒ‰ç« èŠ‚IDæ’åº
                this.chapters.sort((a, b) => {
                    const idA = parseInt(a.id) || 0;
                    const idB = parseInt(b.id) || 0;
                    return idA - idB;
                });
                
                this.filteredChapters = [...this.chapters];
                this.render(novelInfo);
            }
            
            render(novelInfo) {
                const contentArea = document.getElementById('contentArea');
                const statsArea = document.getElementById('stats');
                
                if (this.chapters.length === 0) {
                    contentArea.innerHTML = '<div class="error">æœªæ‰¾åˆ°ç« èŠ‚æ•°æ®</div>';
                    return;
                }
                
                // æ˜¾ç¤ºå°è¯´ä¿¡æ¯
                let html = '';
                
                if (novelInfo) {
                    html += `
                        <div class="novel-info">
                            <h2>${novelInfo.title}</h2>
                            <p>ä½œè€…ï¼š${novelInfo.author} | çŠ¶æ€ï¼š${novelInfo.status}</p>
                        </div>
                    `;
                }
                
                // æ˜¾ç¤ºç« èŠ‚åˆ—è¡¨
                html += '<div class="chapter-list">';
                
                this.filteredChapters.forEach(chapter => {
                    html += `
                        <div class="chapter-item">
                            <a href="${chapter.url}" class="chapter-link" target="_blank">
                                ${chapter.title}
                            </a>
                            <div class="chapter-id">ç¬¬${chapter.id}ç« </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                contentArea.innerHTML = html;
                
                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                statsArea.innerHTML = `
                    å…± ${this.chapters.length} ä¸ªç« èŠ‚ | 
                    æ˜¾ç¤º ${this.filteredChapters.length} ä¸ª
                `;
            }
            
            searchChapters(keyword) {
                if (!keyword.trim()) {
                    this.filteredChapters = [...this.chapters];
                } else {
                    this.filteredChapters = this.chapters.filter(chapter => 
                        chapter.title.includes(keyword) || 
                        chapter.id.includes(keyword)
                    );
                }
                
                // é‡æ–°æ¸²æŸ“
                const novelInfo = this.chapters.length > 0 ? {
                    title: "é‡ç”Ÿåå¨±ï¼Œä½†ç»‘å®šäº†ç½ªçŠ¯ç³»ç»Ÿ",
                    author: "æœªçŸ¥ä½œè€…",
                    status: "è¿è½½ä¸­",
                    totalChapters: this.chapters.length.toString()
                } : null;
                
                this.render(novelInfo);
            }
            
            exportList() {
                const content = this.chapters.map(chapter => 
                    `${chapter.id}. ${chapter.title}`
                ).join('\n');
                
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ç« èŠ‚æ¸…å•.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            showError(message) {
                document.getElementById('contentArea').innerHTML = `
                    <div class="error">
                        <h3>é”™è¯¯</h3>
                        <p>${message}</p>
                        <p>å¯èƒ½çš„åŸå› ï¼š</p>
                        <ul>
                            <li>OPMLæ–‡ä»¶ç¼–ç ä¸æ­£ç¡®</li>
                            <li>æ–‡ä»¶è·¯å¾„é”™è¯¯</li>
                            <li>XMLæ ¼å¼æœ‰è¯¯</li>
                        </ul>
                        <button onclick="viewer.loadOPML()" class="control-btn">é‡è¯•</button>
                    </div>
                `;
            }
        }
        
        // åˆ›å»ºå®ä¾‹
        const viewer = new OPMLViewer();
        
        // å…¨å±€å‡½æ•°ä¾›æŒ‰é’®è°ƒç”¨
        window.loadOPML = () => viewer.loadOPML();
        window.exportList = () => viewer.exportList();
        window.searchChapters = (keyword) => viewer.searchChapters(keyword);
        
        // æ·»åŠ é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.querySelector('.search-input').focus();
            }
        });



        class ChapterSpeech {
            constructor() {
                this.speech = window.speechSynthesis;
                this.currentUtterance = null;
                this.currentParagraphs = [];
                this.currentIndex = 0;
                this.isPlaying = false;
                this.rate = 1.0;
                this.voices = [];
                this.selectedVoice = null;
                
                this.init();
            }
            
            async init() {
                await this.loadVoices();
                this.speech.onvoiceschanged = () => this.loadVoices();
            }
            
            loadVoices() {
                return new Promise((resolve) => {
                    const voices = this.speech.getVoices();
                    this.voices = voices;
                    
                    const select = document.getElementById('chapterVoiceSelect');
                    select.innerHTML = '<option value="">é€‰æ‹©è¯­éŸ³</option>';
                    
                    // ä¼˜å…ˆä¸­æ–‡è¯­éŸ³
                    const chineseVoices = voices.filter(v => 
                        v.lang.startsWith('zh') || 
                        v.name.toLowerCase().includes('chinese')
                    );
                    
                    chineseVoices.forEach((voice, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        select.appendChild(option);
                    });
                    
                    if (chineseVoices.length > 0) {
                        this.selectedVoice = chineseVoices[0];
                        select.value = voices.indexOf(chineseVoices[0]);
                    }
                    
                    resolve();
                });
            }
            
            async speakChapter(url) {
                try {
                    // åŠ è½½ç« èŠ‚å†…å®¹
                    const response = await fetch(url);
                    const text = await response.text();
                    
                    // åˆ†å‰²æˆæ®µè½
                    this.currentParagraphs = text.split('\n').filter(p => p.trim());
                    this.currentIndex = 0;
                    
                    // å¼€å§‹æœ—è¯»
                    this.startReading();
                    
                    // æ˜¾ç¤ºæ§åˆ¶é¢æ¿
                    document.getElementById('speechControls').style.display = 'flex';
                    
                } catch (error) {
                    console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', error);
                    this.updateStatus('åŠ è½½å¤±è´¥');
                }
            }
            
            startReading() {
                if (this.currentIndex >= this.currentParagraphs.length) return;
                
                const text = this.currentParagraphs[this.currentIndex];
                if (!text) {
                    this.nextParagraph();
                    return;
                }
                
                this.stopReading();
                
                this.currentUtterance = new SpeechSynthesisUtterance(text);
                this.currentUtterance.rate = this.rate;
                this.currentUtterance.pitch = 1;
                this.currentUtterance.volume = 1;
                this.currentUtterance.lang = 'zh-CN';
                
                if (this.selectedVoice) {
                    this.currentUtterance.voice = this.selectedVoice;
                }
                
                // é«˜äº®å½“å‰æœ—è¯»çš„æ–‡æœ¬
                this.highlightCurrentText(text);
                
                this.currentUtterance.onstart = () => {
                    this.isPlaying = true;
                    this.updateUI();
                    this.updateStatus('æœ—è¯»ä¸­...');
                };
                
                this.currentUtterance.onend = () => {
                    this.isPlaying = false;
                    this.nextParagraph();
                    this.updateUI();
                };
                
                this.currentUtterance.onerror = () => {
                    this.isPlaying = false;
                    this.updateUI();
                    this.updateStatus('å‡ºé”™');
                };
                
                this.speech.speak(this.currentUtterance);
            }
            
            stopReading() {
                if (this.speech.speaking) {
                    this.speech.cancel();
                    this.isPlaying = false;
                    this.clearHighlight();
                    this.updateUI();
                    this.updateStatus('å·²åœæ­¢');
                }
            }
            
            toggleReading() {
                if (this.isPlaying) {
                    if (this.speech.paused) {
                        this.speech.resume();
                        this.isPlaying = true;
                        this.updateStatus('ç»§ç»­');
                    } else {
                        this.speech.pause();
                        this.isPlaying = false;
                        this.updateStatus('å·²æš‚åœ');
                    }
                } else {
                    this.startReading();
                }
            }
            
            nextParagraph() {
                if (this.currentIndex < this.currentParagraphs.length - 1) {
                    this.currentIndex++;
                    setTimeout(() => this.startReading(), 100);
                } else {
                    this.updateStatus('æœ—è¯»å®Œæˆ');
                    this.currentIndex = 0;
                }
            }
            
            prevParagraph() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.stopReading();
                    this.startReading();
                }
            }
            
            setRate(newRate) {
                this.rate = newRate;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.rate-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');
                
                // å¦‚æœæ­£åœ¨æœ—è¯»ï¼Œæ›´æ–°é€Ÿç‡
                if (this.currentUtterance && this.isPlaying) {
                    this.speech.cancel();
                    this.currentUtterance.rate = newRate;
                    this.speech.speak(this.currentUtterance);
                }
            }
            
            changeVoice(voiceIndex) {
                if (voiceIndex !== '' && this.voices[voiceIndex]) {
                    this.selectedVoice = this.voices[voiceIndex];
                    
                    if (this.currentUtterance && this.isPlaying) {
                        this.speech.cancel();
                        this.currentUtterance.voice = this.selectedVoice;
                        this.speech.speak(this.currentUtterance);
                    }
                }
            }
            
            highlightCurrentText(text) {
                // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
                this.clearHighlight();
                
                // æŸ¥æ‰¾å¹¶é«˜äº®åŒ…å«æ­¤æ–‡æœ¬çš„å…ƒç´ 
                const elements = document.querySelectorAll('p, div, span');
                elements.forEach(el => {
                    if (el.textContent.includes(text.trim())) {
                        el.classList.add('reading-highlight');
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });
            }
            
            clearHighlight() {
                document.querySelectorAll('.reading-highlight').forEach(el => {
                    el.classList.remove('reading-highlight');
                });
            }
            
            updateUI() {
                const btn = document.getElementById('speechPlayBtn');
                if (this.isPlaying) {
                    btn.innerHTML = 'â¸ï¸';
                    btn.classList.add('active');
                } else {
                    btn.innerHTML = 'â–¶ï¸';
                    btn.classList.remove('active');
                }
            }
            
            updateStatus(message) {
                document.getElementById('speechStatus').textContent = message;
            }
        }
        
        // åˆ›å»ºè¯­éŸ³å®ä¾‹
        const chapterSpeech = new ChapterSpeech();
        
        // å…¨å±€å‡½æ•°
        window.toggleChapterSpeech = () => chapterSpeech.toggleReading();
        window.stopChapterSpeech = () => chapterSpeech.stopReading();
        window.setSpeechRate = (rate) => chapterSpeech.setRate(rate);
        window.changeChapterVoice = (voiceIndex) => chapterSpeech.changeVoice(voiceIndex);
        
        // åœ¨ä½ çš„ç« èŠ‚ç‚¹å‡»äº‹ä»¶ä¸­æ·»åŠ è¯­éŸ³åŠŸèƒ½
        function loadChapterWithSpeech(url, title) {
            // åŸæ¥çš„åŠ è½½ç« èŠ‚é€»è¾‘...
            
            // æ·»åŠ è¯­éŸ³æœ—è¯»æŒ‰é’®
            const contentDiv = document.getElementById('chapterContent');
            const speechBtn = document.createElement('button');
            speechBtn.innerHTML = 'ğŸ¤ è¯­éŸ³æœ—è¯»æœ¬ç« ';
            speechBtn.style.cssText = `
                padding: 10px 20px;
                background: #3498db;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin: 20px 0;
            `;
            speechBtn.onclick = () => chapterSpeech.speakChapter(url);
            
            contentDiv.parentNode.insertBefore(speechBtn, contentDiv.nextSibling);
        }
    </script>
</body>
</html>