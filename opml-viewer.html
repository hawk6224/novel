<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPMLå°è¯´ç›®å½•æµè§ˆå™¨</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --bg-color: #f8f9fa;
            --text-color: #333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            padding: 30px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .novel-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .chapter-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .chapter-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            transition: all 0.3s;
        }
        
        .chapter-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .chapter-link {
            color: var(--secondary-color);
            text-decoration: none;
            display: block;
            font-size: 16px;
            font-weight: 500;
        }
        
        .chapter-link:hover {
            color: var(--primary-color);
        }
        
        .chapter-id {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            color: #e74c3c;
            background: #ffeaea;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .control-btn:hover {
            background: #2980b9;
        }
        
        .search-box {
            flex: 1;
            min-width: 200px;
        }
        
        .search-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .stats {
            margin-top: 20px;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“š å°è¯´ç›®å½•æµè§ˆå™¨</h1>
            <p>è‡ªåŠ¨å¤„ç†ç¼–ç é—®é¢˜ï¼Œæ˜¾ç¤ºæ­£ç¡®ä¸­æ–‡</p>
        </div>
        
        <div class="controls">
            <button class="control-btn" onclick="loadOPML()">é‡æ–°åŠ è½½</button>
            <button class="control-btn" onclick="exportList()">å¯¼å‡ºæ¸…å•</button>
            <div class="search-box">
                <input type="text" class="search-input" placeholder="æœç´¢ç« èŠ‚..." oninput="searchChapters(this.value)">
            </div>
        </div>
        
        <div id="contentArea">
            <div class="loading">æ­£åœ¨åŠ è½½å°è¯´ç›®å½•...</div>
        </div>
        
        <div class="stats" id="stats"></div>
    </div>
    
    <script>
        class OPMLViewer {
            constructor() {
                this.chapters = [];
                this.filteredChapters = [];
                this.init();
            }
            
            async init() {
                await this.loadOPML();
            }
            
            async loadOPML() {
                const contentArea = document.getElementById('contentArea');
                contentArea.innerHTML = '<div class="loading">æ­£åœ¨åŠ è½½OPMLæ–‡ä»¶...</div>';
                
                try {
                    // å°è¯•ä¸åŒç¼–ç æ–¹å¼åŠ è½½
                    const response = await fetch('novels.opml');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // å°è¯•å¤šç§ç¼–ç 
                    const encodings = ['utf-8', 'gbk', 'gb2312', 'big5'];
                    let xmlText = '';
                    
                    // å…ˆä»¥ ArrayBuffer æ–¹å¼è·å–åŸå§‹æ•°æ®
                    const buffer = await response.arrayBuffer();
                    
                    for (const encoding of encodings) {
                        try {
                            const decoder = new TextDecoder(encoding);
                            xmlText = decoder.decode(buffer);
                            
                            // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
                            if (this.containsChinese(xmlText)) {
                                console.log(`ä½¿ç”¨ç¼–ç : ${encoding}`);
                                break;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    if (!this.containsChinese(xmlText)) {
                        // å¦‚æœè¿˜æ˜¯ä¸è¡Œï¼Œå°è¯•é»˜è®¤utf-8
                        xmlText = new TextDecoder('utf-8').decode(buffer);
                    }
                    
                    // è§£æ XML
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    // æ£€æŸ¥è§£æé”™è¯¯
                    const parserError = xmlDoc.querySelector('parsererror');
                    if (parserError) {
                        throw new Error('XMLè§£æé”™è¯¯ï¼š' + parserError.textContent);
                    }
                    
                    // æå–ä¿¡æ¯
                    this.extractData(xmlDoc);
                    
                } catch (error) {
                    console.error('åŠ è½½å¤±è´¥:', error);
                    this.showError(`åŠ è½½å¤±è´¥: ${error.message}`);
                }
            }
            
            containsChinese(text) {
                // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
                return /[\u4e00-\u9fff]/.test(text);
            }
            
            extractData(xmlDoc) {
                this.chapters = [];
                const outlines = xmlDoc.getElementsByTagName('outline');
                
                // æŸ¥æ‰¾å°è¯´ä¿¡æ¯
                let novelInfo = null;
                for (const outline of outlines) {
                    if (outline.getAttribute('type') === 'novel') {
                        novelInfo = {
                            title: outline.getAttribute('text') || 'æœªçŸ¥å°è¯´',
                            author: outline.getAttribute('author') || 'æœªçŸ¥ä½œè€…',
                            status: outline.getAttribute('status') || 'æœªçŸ¥çŠ¶æ€',
                            totalChapters: outline.getAttribute('totalChapters') || '0'
                        };
                        break;
                    }
                }
                
                // æå–ç« èŠ‚
                for (const outline of outlines) {
                    if (outline.getAttribute('type') === 'chapter') {
                        const chapter = {
                            id: outline.getAttribute('chapterId') || '',
                            title: outline.getAttribute('text') || '',
                            url: outline.getAttribute('url') || '',
                            filename: outline.getAttribute('filename') || ''
                        };
                        
                        if (chapter.title && chapter.url) {
                            this.chapters.push(chapter);
                        }
                    }
                }
                
                // æŒ‰ç« èŠ‚IDæ’åº
                this.chapters.sort((a, b) => {
                    const idA = parseInt(a.id) || 0;
                    const idB = parseInt(b.id) || 0;
                    return idA - idB;
                });
                
                this.filteredChapters = [...this.chapters];
                this.render(novelInfo);
            }
            
            render(novelInfo) {
                const contentArea = document.getElementById('contentArea');
                const statsArea = document.getElementById('stats');
                
                if (this.chapters.length === 0) {
                    contentArea.innerHTML = '<div class="error">æœªæ‰¾åˆ°ç« èŠ‚æ•°æ®</div>';
                    return;
                }
                
                // æ˜¾ç¤ºå°è¯´ä¿¡æ¯
                let html = '';
                
                if (novelInfo) {
                    html += `
                        <div class="novel-info">
                            <h2>${novelInfo.title}</h2>
                            <p>ä½œè€…ï¼š${novelInfo.author} | çŠ¶æ€ï¼š${novelInfo.status}</p>
                        </div>
                    `;
                }
                
                // æ˜¾ç¤ºç« èŠ‚åˆ—è¡¨
                html += '<div class="chapter-list">';
                
                this.filteredChapters.forEach(chapter => {
                    html += `
                        <div class="chapter-item">
                            <a href="${chapter.url}" class="chapter-link" target="_blank">
                                ${chapter.title}
                            </a>
                            <div class="chapter-id">ç¬¬${chapter.id}ç« </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                contentArea.innerHTML = html;
                
                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                statsArea.innerHTML = `
                    å…± ${this.chapters.length} ä¸ªç« èŠ‚ | 
                    æ˜¾ç¤º ${this.filteredChapters.length} ä¸ª
                `;
            }
            
            searchChapters(keyword) {
                if (!keyword.trim()) {
                    this.filteredChapters = [...this.chapters];
                } else {
                    this.filteredChapters = this.chapters.filter(chapter => 
                        chapter.title.includes(keyword) || 
                        chapter.id.includes(keyword)
                    );
                }
                
                // é‡æ–°æ¸²æŸ“
                const novelInfo = this.chapters.length > 0 ? {
                    title: "é‡ç”Ÿåå¨±ï¼Œä½†ç»‘å®šäº†ç½ªçŠ¯ç³»ç»Ÿ",
                    author: "æœªçŸ¥ä½œè€…",
                    status: "è¿è½½ä¸­",
                    totalChapters: this.chapters.length.toString()
                } : null;
                
                this.render(novelInfo);
            }
            
            exportList() {
                const content = this.chapters.map(chapter => 
                    `${chapter.id}. ${chapter.title}`
                ).join('\n');
                
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ç« èŠ‚æ¸…å•.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            showError(message) {
                document.getElementById('contentArea').innerHTML = `
                    <div class="error">
                        <h3>é”™è¯¯</h3>
                        <p>${message}</p>
                        <p>å¯èƒ½çš„åŸå› ï¼š</p>
                        <ul>
                            <li>OPMLæ–‡ä»¶ç¼–ç ä¸æ­£ç¡®</li>
                            <li>æ–‡ä»¶è·¯å¾„é”™è¯¯</li>
                            <li>XMLæ ¼å¼æœ‰è¯¯</li>
                        </ul>
                        <button onclick="viewer.loadOPML()" class="control-btn">é‡è¯•</button>
                    </div>
                `;
            }
        }
        
        // åˆ›å»ºå®ä¾‹
        const viewer = new OPMLViewer();
        
        // å…¨å±€å‡½æ•°ä¾›æŒ‰é’®è°ƒç”¨
        window.loadOPML = () => viewer.loadOPML();
        window.exportList = () => viewer.exportList();
        window.searchChapters = (keyword) => viewer.searchChapters(keyword);
        
        // æ·»åŠ é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.querySelector('.search-input').focus();
            }
        });
    </script>
</body>
</html>